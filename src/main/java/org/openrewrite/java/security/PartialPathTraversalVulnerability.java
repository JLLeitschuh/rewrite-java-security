package org.openrewrite.java.security;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.lang.Nullable;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.Collections;

public class PartialPathTraversalVulnerability extends Recipe {
    private static final MethodMatcher getCanonicalPathMatcher =
            new MethodMatcher("java.io.File getCanonicalPath()");
    private static final MethodMatcher startsWithMatcher =
            new MethodMatcher("java.lang.String startsWith(java.lang.String)");

    @Override
    public String getDisplayName() {
        return "Partial path traversal vulnerability";
    }

    @Override
    protected @Nullable TreeVisitor<?, ExecutionContext> getSingleSourceApplicableTest() {
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitJavaSourceFile(JavaSourceFile cu, ExecutionContext executionContext) {
                doAfterVisit(new UsesMethod<>(getCanonicalPathMatcher));
                doAfterVisit(new UsesMethod<>(startsWithMatcher));
                return cu;
            }
        };
    }

    @Override
    protected TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PartialPathTraversalVulnerabilityVisitor<>();
    }

    private static class PartialPathTraversalVulnerabilityVisitor<P> extends JavaIsoVisitor<P> {
        private static final JavaType.FullyQualified TYPE_FILE =
                TypeUtils.asFullyQualified(JavaType.buildType("java.io.File"));
        private static final JavaType.FullyQualified TYPE_PATH =
                TypeUtils.asFullyQualified(JavaType.buildType("java.io.Path"));

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, P p) {
            if (startsWithMatcher.matches(method)) {
                assert method.getSelect() != null : "Select is null for `startsWith`";
                final Expression select = unwrap(method.getSelect());
                final Expression argument = unwrap(method.getArguments().get(0));
                if (getCanonicalPathMatcher.matches(select) &&
                        getCanonicalPathMatcher.matches(argument)) {
                    final J.MethodInvocation getCanonicalPathSubject = (J.MethodInvocation) select;
                    final J.MethodInvocation getCanonicalPathArgument = (J.MethodInvocation) argument;
                    final J.MethodInvocation getCanonicalPathSubjectReplacement =
                            replaceGetCanonicalPath(getCanonicalPathSubject);
                    final J.MethodInvocation getCanonicalPathArgumentReplacement =
                            replaceGetCanonicalPath(getCanonicalPathArgument);
                    return maybeAutoFormat(
                            method,
                            method.withSelect(getCanonicalPathSubjectReplacement)
                                    .withArguments(Collections.singletonList(getCanonicalPathArgumentReplacement))
                                    .withMethodType(method.getMethodType().withDeclaringType(TYPE_PATH)),
                            p,
                            getCursor().getParentOrThrow()
                    );
                }
            }
            return super.visitMethodInvocation(method, p);
        }

        private Expression unwrap(Expression expression) {
            if (expression instanceof J.Parentheses) {
                //noinspection unchecked
                return unwrap(((J.Parentheses<Expression>) expression).getTree());
            } else {
                return expression;
            }
        }

        private J.MethodInvocation replaceGetCanonicalPath(J.MethodInvocation getCanonicalPath) {
            final JavaType.Method type =
                    getCanonicalPath
                            .getMethodType()
                            .withName("getCanonicalFile");
            final J.MethodInvocation getCanonicalFileSubject =
                    getCanonicalPath
                            .withName(getCanonicalPath.getName().withSimpleName("getCanonicalFile"))
                            .withMethodType(type);

            final JavaType.Method toPathMethod = new JavaType.Method(
                    null,
                    Flag.Public.getBitMask(),
                    TYPE_FILE,
                    "toPath",
                    TYPE_PATH,
                    Collections.emptyList(),
                    Collections.emptyList(),
                    null,
                    null
            );
            return new J.MethodInvocation(
                    Tree.randomId(),
                    Space.EMPTY,
                    Markers.EMPTY,
                    JRightPadded.build(getCanonicalFileSubject),
                    null,
                    new J.Identifier(
                            Tree.randomId(),
                            Space.EMPTY,
                            Markers.EMPTY,
                            "toPath",
                            null,
                            null
                    ),
                    JContainer.empty(),
                    toPathMethod
            );
        }
    }
}

package org.openrewrite.java.security;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.lang.Nullable;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;

import java.util.Collections;
import java.util.Set;

public class PartialPathTraversalVulnerability extends Recipe {
    private static final MethodMatcher getCanonicalPathMatcher =
            new MethodMatcher("java.io.File getCanonicalPath()");
    private static final MethodMatcher startsWithMatcher =
            new MethodMatcher("java.lang.String startsWith(java.lang.String)");

    @Override
    public String getDisplayName() {
        return "Partial path traversal vulnerability";
    }

    @Override
    public String getDescription() {
        return "Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath()`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\n" +
                "To demonstrate this vulnerability, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`. The check is bypassed although `/outnot` is not under the `/out` directory. " +
                "It's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object. " +
                "For example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`; " +
                "however, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.";
    }

    @Override
    public Set<String> getTags() {
        return Collections.singleton("CWE-22");
    }

    @Override
    protected @Nullable TreeVisitor<?, ExecutionContext> getSingleSourceApplicableTest() {
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitJavaSourceFile(JavaSourceFile cu, ExecutionContext executionContext) {
                doAfterVisit(new UsesMethod<>(getCanonicalPathMatcher));
                doAfterVisit(new UsesMethod<>(startsWithMatcher));
                return cu;
            }
        };
    }

    @Override
    protected TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PartialPathTraversalVulnerabilityVisitor<>();
    }

    private static class PartialPathTraversalVulnerabilityVisitor<P> extends JavaIsoVisitor<P> {
        private final JavaTemplate toPathTemplate =
                JavaTemplate
                        .builder(this::getCursor, "#{any(java.io.File)}.getCanonicalFile().toPath()")
                        .build();
        private final JavaTemplate pathStartsWithTemplate =
                JavaTemplate
                        .builder(this::getCursor, "#{any(java.nio.file.Path)}.startsWith(#{any(java.nio.file.Path)})")
                        .build();

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, P p) {
            if (startsWithMatcher.matches(method)) {
                assert method.getSelect() != null : "Select is null for `startsWith`";
                final Expression select = unwrap(method.getSelect());
                final Expression argument = unwrap(method.getArguments().get(0));
                if (getCanonicalPathMatcher.matches(select) &&
                        getCanonicalPathMatcher.matches(argument)) {
                    final J.MethodInvocation getCanonicalPathSubject = (J.MethodInvocation) select;
                    final J.MethodInvocation getCanonicalPathArgument = (J.MethodInvocation) argument;
                    final J.MethodInvocation getCanonicalPathSubjectReplacement =
                            replaceGetCanonicalPath(getCanonicalPathSubject);
                    final J.MethodInvocation getCanonicalPathArgumentReplacement =
                            replaceGetCanonicalPath(getCanonicalPathArgument);
                    return method
                            .withTemplate(
                                    pathStartsWithTemplate,
                                    method.getCoordinates().replace(),
                                    getCanonicalPathSubjectReplacement,
                                    getCanonicalPathArgumentReplacement
                            );
                }
            }
            return super.visitMethodInvocation(method, p);
        }

        private static Expression unwrap(Expression expression) {
            if (expression instanceof J.Parentheses) {
                //noinspection unchecked
                return unwrap(((J.Parentheses<Expression>) expression).getTree());
            } else {
                return expression;
            }
        }

        private J.MethodInvocation replaceGetCanonicalPath(J.MethodInvocation getCanonicalPath) {
            return getCanonicalPath
                    .withTemplate(
                            toPathTemplate,
                            getCanonicalPath.getCoordinates().replace(),
                            getCanonicalPath.getSelect()
                    );
        }
    }
}
